local Settings = require(script:WaitForChild("Settings"))
local Utilities = require(script:WaitForChild("Utilities"))

--[=[
    @class BreakerBox
    @client
    @server

    BreakerBoxes are for individual script-objects (designed in an OOP scheme) for managing connections.

    Specifically, these are connections that are routinely open.  Rather than leaving connections open when they are not needed (or dealing with messy cleanup), BreakerBox allows for quick management of active connections.

    BreakerBoxes are distinct from Maid objects, because they are intended for connections that *at some later point* will return.  Rather than cleaning up these connections everytime, a BreakerBox acts somewhat like a circuit breaker - breaking the connection completely when 'opened' and restoring normal state when 'closed'.
    
    Example in the context of UI:
    * BreakerBoxes are appropriate for connections that would otherwise remain open (ex: for instances that are never destroyed, data which changes and is updated by the UI, etc.)
    * BreakerBoxes are not appropriate for buttons that are generated by the UI and destroyed - these connections would already be handled there
]=]
local BreakerBox = {}
BreakerBox.__index = BreakerBox --// Metamethod

--[=[
    @class BreakerBoxManager
    @client
    @server

    Central node generating BreakerBoxes in an OOP construct.
]=]
local BreakerBoxManager = {}

--[=[
    @function new
    @within BreakerBoxManager

    Constructor function for creating BreakerBoxes.

    @return BreakerBox
]=]
function BreakerBoxManager.new()
	local NewBreakerBox = {}

	--// Assign initial properties
	local PropertyTable = Utilities:DeepCopyTable(Settings["Initial Properties"])

	for PropertyName, PropertyValue in pairs (PropertyTable) do
		NewBreakerBox[PropertyName] = PropertyValue
	end

	setmetatable(NewBreakerBox, BreakerBox) --// When NewBreakerBox is indexed and the value is nil, indexes within BreakerBox

	return NewBreakerBox
end

function BreakerBox:__CreateConnection(ConnectionData: table)
	local Signal = ConnectionData["Signal"]
	local BoundFunction = ConnectionData["Bound Function"]
	local Arguments = ConnectionData["Arguments"]
	local IsOpen = ConnectionData["Open"]
	local InitiallyOpened = ConnectionData["Initially Opened"]

	if IsOpen and not InitiallyOpened then
		Utilities:StackTraceWarn("Attempted to restore a Breaker that is already open.")

		return
	end

	--[[
		BreakerBox pop a warning (above) if an existing Breaker is opened.
		However, to allow Breakers to be opened immediately upon creation, `InitiallyOpened` exists which basically tells the module whether this is the first time the Breaker is being opened.
		If it is the first time and `IsOpen` is true, that just means the developer manually set `OpenBreaker` to true, so we can allow this to occur.
		This only matters the first time the connection is opened, so we set `InitiallyOpened` to nil afterwards and treat it as an ordinary Breaker thereafter.
	]]
	if InitiallyOpened then
		ConnectionData["Initially Opened"] = nil
	end

	local Connection

	if Arguments then
		Connection = Signal:Connect(function(...)
			local SignalArguments = {...}

			local ModifiedArguments = Utilities:DeepCopyTable(Arguments)
			
			for Index, SignalArgument in pairs (SignalArguments) do --// Insert the arguments provided by the signal to the function
				table.insert(ModifiedArguments, Index, SignalArgument)
			end
			
			BoundFunction(table.unpack(Arguments))
		end)
	else
		Connection = Signal:Connect(function(...)
			local SignalArguments = {...}

			BoundFunction(table.unpack(SignalArguments))
		end)
	end

	table.insert(self["Active Connections"], Connection)
	ConnectionData["Open"] = true
end

--[=[
    @method AddBreaker
    @within BreakerBox

    @param Signal RBXScriptSignal | Signal
    @param BoundFunction function
    @param Arguments table | nil
    @param OpenBreaker boolean | nil

    Connects the given function and arguments to the given signal.  Arguments may be passed as an array, which will be unpacked into the function

    Breakers default to 'closed' vice 'open'.  When breakers are 'closed' the connection is not active and need to be 'opened' via the :Restore method.  When breakers are 'open' the connection is immediately active
]=]
function BreakerBox:AddBreaker(Signal: RBXScriptSignal, BoundFunction, Arguments: table?, OpenBreaker: boolean?)
	if type(BoundFunction) ~= "function" then
		Utilities:StackTraceWarn("Failed to create breaker - function not passed")

		return
	end

	if Arguments and type(Arguments) ~= "table" then
		Utilities:StackTraceWarn("Failed to create breaker - arguments must be passed as an array")

		return
	end

	if OpenBreaker and type(OpenBreaker) ~= "boolean" then
		Utilities:StackTraceWarn("Failed to create breaker - OpenBreaker must be a boolean if declared")

		return
	end

	local ConnectionData = {
		["Signal"] = Signal,
		["Bound Function"] = BoundFunction,
		["Arguments"] = Arguments,
		["Open"] =  OpenBreaker or false,
		["Initially Opened"] = OpenBreaker or nil,
	}

	table.insert(self["Connection Summary"], ConnectionData)

	if not OpenBreaker then
		return
	end

	self:__CreateConnection(ConnectionData) --// Returns anything that the function returns
end

--[=[
    @method AddBreakersFromArray
    @within BreakerBox

    @param Arrray table

    Adds breakers *en masse*, through a passed array.  Array values are dictionaries with the following key pairs: ["Signal"] = RBXScriptSignal | Signal, ["Function"] = function, ["Arguments"] = table | nil, ["OpenBreaker"] = boolean | nil
]=]
function BreakerBox:AddBreakersFromArray(Array: table)
	for _, Dictionary in ipairs (Array) do
		local Signal = Dictionary["Signal"]
		local Function = Dictionary["Function"]
		local Arguments = Dictionary["Arguments"] --// Optional
		local OpenBreaker = Dictionary["OpenBreaker"] --// Optional

		if not Signal then
			Utilities:StackTraceWarn("Missing critical element: Signal.  Failed to create breaker with the following dictionary", Dictionary)

			continue
		end

		if not Function then
			Utilities:StackTraceWarn("Missing critical element: Function.  Failed to create breaker with the following dictionary", Dictionary)

			continue
		end

		self:AddBreaker(Signal, Function, Arguments, OpenBreaker)
	end
end

--[=[
    @method BreakAll
    @within BreakerBox

    Disconnects all active connections handled by the breaker
]=]
function BreakerBox:BreakAll()
	for _, Connection: RBXScriptConnection in pairs (self["Active Connections"]) do
		Connection:Disconnect()
	end

    table.clear(self["Active Connections"])

	for _, ConnectionData: table in pairs (self["Connection Summary"]) do
		ConnectionData["Open"] = false
	end
end

--[=[
    @method Restore
    @within BreakerBox

    Restores all active connections handled by the breaker
]=]
function BreakerBox:Restore()
	for _, ConnectionData: table in pairs (self["Connection Summary"]) do
		self:__CreateConnection(ConnectionData)
	end
end

return BreakerBoxManager